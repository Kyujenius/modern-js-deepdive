# 일급 함수(=일급 객체)가 React의 작동 원리와 DX를 어떻게 지탱하는가?

## React에서 드러나는 일급 함수의 힘

## 1. React 자체가 함수형 모델이다

React는 “UI = f(state, props)”라는 순수 함수 모델 위에 선다. 컴포넌트는 함수고, 이 함수는 같은 입력이면 같은 뷰를 만들어야 한다. (부수효과는 렌더 단계가 아니라 효과 단계에 둔다.)

좋은 예(순수):

```js
function Price({ amount, currency }) {
  const formatted = new Intl.NumberFormat(undefined, {
    style: "currency",
    currency,
  }).format(amount);
  return <span>{formatted}</span>;
}
```

- 입력만으로 출력 결정. 테스트가 쉽고 예측 가능.

나쁜 예(불순):

```js
function Bad({ url }) {
  // ❌ 렌더 중 네트워크 호출(부수효과)
  const data = fetch(url);
  return <div>{String(data)}</div>;
}
```

- 렌더는 순수해야 한다. 데이터 로딩/구독은 훅으로 분리.

“함수는 값”이기에 가능한 것들

- 컴포넌트를 값처럼 전달/조립: 렌더 프롭(Render Prop), 슬롯(Slot) 패턴.

```js
function List({ items, renderItem }) {
  return (
    <ul>
      {items.map((it, i) => (
        <li key={i}>{renderItem(it)}</li>
      ))}
    </ul>
  );
}

<List items={users} renderItem={(u) => <UserRow user={u} />} />;
```

- renderItem은 함수 값이다. 호출 시점/문맥을 자유롭게 제어 가능.
- 렌더 함수 안에서 타이머/이벤트 등록/네트워크 호출 금지.
- 파생 값은 렌더에서 계산하되, **무거우면 useMemo**로 캐싱.

## 2. 훅(Hooks)은 고계 함수다

핵심 주장

훅은 **함수를 인자로 받거나 반환하는 고계 함수(HOF)** 다. 이 구조 덕에 상태/부수효과/구독을 조립 가능한 함수로 추상화한다.

useEffect의 본질

- useEffect(effectFn, deps)에서 인자로 받은 함수를 React가 효과 단계에 호출한다.
- 정리는 함수가 함수를 반환(cleanup)하는 형태로 캡슐화한다.

```js
useEffect(() => {
  const id = setInterval(tick, 1000);
  return () => clearInterval(id); // 함수가 cleanup(또 다른 함수)을 반환
}, [tick]);
```

“함수가 값”일 때 생기는 함정 — Stale Closure

```js
function Timer() {
  const [n, setN] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      // ❌ 오래된 n을 캡처하면 1에서 멈춤
      setN(n + 1);
    }, 1000);
    return () => clearInterval(id);
  }, []); // deps가 비어 stale
}
```

해결

- 함수형 업데이트: 최신 상태를 안전하게 참조.

```js
setN((prev) => prev + 1);
```

- 혹은 의존성을 정확히 선언하거나, 안정된 함수를 useCallback으로 제공.

커스텀 훅: 함수 합성의 결과물

```js
function useEventListener(target, type, handler) {
  useEffect(() => {
    target.addEventListener(type, handler);
    return () => target.removeEventListener(type, handler);
  }, [target, type, handler]);
}

// 사용
useEventListener(window, "resize", onResize);
```

- 훅 자체가 고계 함수이므로, 앱 전역의 부수효과 정책을 재사용 가능한 함수 모듈로 만든다.
- useEffect deps는 코드가 의존하는 모든 함수/값을 적는다.
- 이벤트 핸들러/콜백은 useCallback으로 참조 안정화(아래 4절과 연결).

## 3. 미들웨어·콜백 체인: 함수 합성으로 흐름을 제어한다

### 핵심 주장

Redux 미들웨어, 로깅/메트릭/리트라이 같은 횡단 관심사는 “함수를 감싸 또 다른 함수를 만드는” 고계 함수 합성으로 구현된다.

미들웨어 미니 예제(핵심만)

```js
const logger = (store) => (next) => (action) => {
  console.log("[act]", action.type);
  return next(action);
};

const retry = (times) => (store) => (next) => (action) => {
  let i = 0;
  while (i++ < times) {
    try {
      return next(action);
    } catch (e) {
      if (i === times) throw e;
    }
  }
};

// 합성
const apply = (...mws) =>
  mws.reduceRight((next, mw) => mw(store)(next), baseDispatch);
```

- 함수 → 함수를 반환하는 계단식 구조.
- 필요 기능을 조립해 실행 파이프라인을 만든다.

### 컴포넌트 레벨에서도 동일

- 로깅/권한/실험군 주입 등을 HOC(고계 컴포넌트) 또는 컴포넌트 합성으로 구현.
- 본질은 같다: 함수를 감싸 책임을 추가한다.

### 실무 팁

- 미들웨어/데코레이터는 단일 책임을 지키고, 작은 단위로 쪼개 합성하라.
- 테스트는 **입력(Action/Props) → 출력(호출/Side-effect)** 만 검증하면 된다. 함수형이라 쉽다.

## 4. 컴포넌트 합성은 함수 합성이다

### 핵심 주장

작은 컴포넌트를 값처럼 조합해 큰 UI를 만든다. 이때 함수의 참조 안정성이 렌더 비용을 좌우한다.

### Render Prop(함수 프롭) 패턴

```js
function Data({ select, children }) {
  const data = useData();
  return children(select(data)); // children도 "함수 값"일 수 있다
}

<Data select={(d) => d.users}>{(users) => <UserTable users={users} />}</Data>;
```

### 함수 프롭과 리렌더

- 문제: 부모가 매 렌더마다 새 함수를 만들면, 자식의 React.memo가 무력화된다.
- 해결: useCallback/useMemo로 참조를 안정화.

```js
const selectUsers = useCallback((d) => d.users, []);
<Data select={selectUsers}>{/_ ... _/}</Data>;
```

### 리스트 합성 디테일

- key는 안정된 식별자여야 한다. 인덱스 key는 재정렬/삽입 시 재마운트를 유발한다.

```js
items.map((item) => <Row key={item.id} item={item} />); // ✅
```

### 실무 팁

- “함수 프롭 + React.memo” 조합을 쓴다면 반드시 참조 안정화를 고려하라.
- 큰 리스트는 **윈도우링(react-window 등)** 과 함께 써서 함수 호출·렌더 수 자체를 줄여라.

## 5. 결론 — React는 일급 함수 위에 선다

요지는 단순하다. 함수가 값이기 때문에 React는 다음을 성취했다.

- 선언적 렌더링: 입력만으로 출력을 만드는 순수 함수 모델.
- 훅 체계: 함수를 인자로 받아 부수효과/상태/구독을 모듈화.
- 미들웨어/데코레이터: 고계 함수 합성으로 횡단 관심사를 주입.
- 컴포넌트 합성: 작은 함수 컴포넌트들을 값처럼 조립.

따라서 React 개발자는 반드시 아래 원칙을 실천하는 게 좋다.

최종 체크리스트

- 렌더는 순수해야 한다. 부수효과는 훅으로 분리.
- 훅의 deps는 코드가 실제로 의존하는 모든 항목을 선언.
- 함수 프롭/핸들러는 useCallback으로 참조 안정화.
- 무거운 계산은 useMemo로 캐시; 리스트는 안정 key.
- 횡단 관심사는 **고계 함수(미들웨어/데코레이터)** 로 주입.
- 테스트는 함수처럼: 입력 → 출력만 검증.

## 결론:

일급 함수를 모르면 React를 “겉보기만” 안다. 진짜 숙달은 함수를 조립 가능한 값으로 다루는 데서 시작한다.
