# 자바스크립트 함수는 왜 일급 객체인가, 그리고 왜 중요한가

## 1. 함수는 값이다

자바스크립트에서 함수는 **일급 객체(First-Class Citizen)** 다.

이 말은 곧 함수가 일반 값처럼 자유롭게 다뤄진다는 뜻이다. 변수에 할당할 수 있고, 다른 함수의 인자로 전달할 수 있으며, 반환값으로 쓸 수도 있다. 심지어 객체나 배열 같은 자료구조에 저장할 수도 있다.

다시 말해, 자바스크립트에서 함수는 단순한 실행 단위가 아니라 조작 가능한 값이다. 이 점 하나가 JS를 근본적으로 다른 언어로 만든다.

## 2. 함수형 프로그래밍의 기반

함수를 값으로 다룰 수 있기 때문에, 자바스크립트에서는 **함수형 프로그래밍(FP)** 이 가능하다. FP의 핵심 도구인 고계 함수(Higher-Order Function), 클로저(Closure), **합성(Composition)** 이 전부 일급 함수라는 전제 위에서 성립한다.

### 2.1 고계 함수

함수를 인자로 받고 함수를 반환하는 함수.
대표적인 예시가 map, filter, reduce다.
데이터 흐름을 선언적으로 기술할 수 있다. 이게 없으면 React 훅도, Redux 리듀서도 존재하지 못한다.

### 2.2 클로저

외부 스코프를 기억하는 함수. 상태 은닉과 캡슐화를 가능하게 한다.
클로저가 없었다면, 자바스크립트에서 안전한 모듈 패턴은 불가능했을 것이다.

### 2.3 함수 합성

작은 함수들을 연결해 더 큰 기능을 만든다.
“조립 가능한 부품”이라는 개념이 여기서 실현된다.
합성이 없다면 재사용성, 테스트 가능성, 선언적 프로그래밍 전부 허상에 불과하다.

## 3. 실전에서의 위력

함수를 값으로 다루는 능력은 이론적인 이야기에 그치지 않는다. 자바스크립트 생태계의 거의 모든 주요 패턴이 여기서 출발한다.

- 미들웨어 패턴: Express, Redux 전부 함수로 기능을 덧씌우는 방식이다.
- 데이터 파이프라인: array.filter().map().reduce()는 루프를 대체하는 게 아니라 의도를 드러내는 언어다.
- 비동기 처리: Promise와 then 체인, async/await 모두 함수를 값으로 전달하는 고계 함수 패턴이다.
- React: React 자체가 (state, props) → UI라는 순수 함수 모델이다. 훅 역시 고계 함수로만 설명된다.

즉, 자바스크립트의 모던 생태계는 전부 일급 함수 위에 세워졌다.

## 4. 객체지향과 충돌하지 않는다

일급 함수는 OOP와도 잘 맞는다. 함수는 객체이므로 데이터와 함께 전달할 수 있다. 의존성 주입, 전략 패턴, 이벤트 핸들링 전부 함수가 값이기 때문에 가능한 것이다.
즉, JS는 “함수형 + 객체지향”을 동시에 취할 수 있는 보기 드문 언어다.

## 5. 주의할 점

강력한 만큼 주의할 점도 있다.

1. 익명 함수 남용 금지: 스택 트레이스가 엉망이 된다. 반드시 이름을 붙여라.

2. 과도한 추상화 경계: 고계 함수를 중첩해 의미 없는 래퍼를 남발하지 마라. 읽기 어려운 코드가 된다.

3. 성능 오해 금지: 함수 생성 비용은 대부분 무시 가능하다. 진짜 병목은 I/O와 DOM 조작이다.

4. 부작용 관리 필수: FP는 순수 함수와 불변성에서 힘을 얻는다. 원본 객체를 직접 수정하지 마라. 즉, 가능한 것과, 좋은 것은 다른 것이다.

5. this 문맥 주의: 함수가 값으로 이동할 때 this가 사라진다. 화살표 함수나 .bind로 고정하라.

## 6. 결론

자바스크립트에서 함수가 일급 객체라는 사실은 단순한 언어적 특징이 아니다. 이것은 현대 JS 생태계를 떠받치는 기둥이다.

함수가 값이기 때문에 미들웨어가 있고, 리듀서가 있고, 훅이 있고, 비동기 처리가 가능하다.
따라서 JS 개발자는 반드시 함수를 값처럼 다루는 사고방식에 익숙해져야 한다.

함수는 단순히 실행되는 코드 덩어리가 아니다.
함수는 조립 가능한 값이며, JS 프로그래밍의 핵심 재료다.
