# 객체 생성 방식 정리

## Object 생성자 함수

- new Object()를 이용해 빈 객체 생성 후 프로퍼티를 추가하는 방식.
- 사실상 잘 쓰이지 않음 → 객체 리터럴({})이 더 간단하고 직관적이기 때문.

```js
const person = new Object();
person.name = "Lee";
person.sayHello = function () {
  console.log(`Hi! My name is ${this.name}`);
};
```

## 내장 생성자 함수 (Built-in Constructor)

- JS는 다양한 생성자 함수를 제공 → String, Number, Boolean, Function, Array, RegExp, Date, Promise 등.
- new 키워드와 함께 호출해 객체(인스턴스)를 생성.

```js
const strObj = new String("Lee"); // 문자열 객체
const numObj = new Number(123); // 숫자 객체
const arr = new Array(1, 2, 3); // 배열 객체
const regExp = new RegExp(/ab+c/i); // 정규표현식 객체
const date = new Date(); // 날짜 객체
```

단점: 원시 값('Lee', 123, true)을 객체로 감싸 불필요한 래퍼 객체를 생성 → 권장되지 않음.

## 객체 리터럴

- {}를 이용한 가장 일반적이고 간단한 객체 생성 방법.
- 필요한 프로퍼티와 메서드를 바로 정의 가능.

```js
const person = {
  name: "Lee",
  sayHello() {
    console.log(`Hi! My name is ${this.name}`);
  },
};
```

장점: 직관적이고 간결.
단점: 동일한 구조(메서드 포함)의 객체 여러 개 생성 시 중복 코드 발생.

## 객체 리터럴의 문제점

- 객체 리터럴로 같은 구조의 객체를 여러 개 만들면 메서드 중복 정의가 발생.
- 메서드 내용이 같아도 각 객체마다 메서드가 별도로 생성되므로 메모리 낭비.

```js
const circle1 = {
  radius: 5,
  getDiameter() {
    return 2 * this.radius;
  },
};

const circle2 = {
  radius: 10,
  getDiameter() {
    return 2 * this.radius;
  },
};

circle1.getDiameter(); // 10
circle2.getDiameter(); // 20
```

문제: circle1과 circle2는 동일한 getDiameter 메서드를 가지고 있지만, 메서드가 객체마다 중복 생성됨.

## 요약

- Object 생성자 함수: 잘 안 씀. 리터럴이 더 간단.
- 내장 생성자 함수: 문자열, 숫자 등 래퍼 객체 만들지만 일반적으로 권장되지 않음.
- 객체 리터럴: 가장 많이 쓰이는 방식, 하지만 메서드 중복 문제 있음.
- 객체 리터럴의 한계: 동일 메서드를 공유할 방법이 없어 비효율적 → 이 문제를 해결하기 위해 생성자 함수 + 프로토타입 방식이 등장하게 됨.

# 생성자 함수와 인스턴스 생성 과정 정리

## 1. 생성자 함수의 장점

- 객체 리터럴은 한 번에 하나의 객체만 생성 가능.
- 생성자 함수(function Circle(radius) {})를 사용하면 동일한 구조의 객체를 여러 개 생성할 수 있음.
- new 키워드와 함께 호출 시 인스턴스를 생성하는 템플릿 역할 수행.

## 2. this의 바인딩

- this는 호출 방식에 따라 참조 대상이 달라짐.

호출 방식 this가 가리키는 값

일반 함수: 호출 전역 객체 (브라우저: window, Node.js: global)
메서드: 호출 메서드를 소유한 객체
생성자 함수: 호출 생성될 인스턴스

-> 따라서 생성자 함수 내부에서 this는 새로 생성된 인스턴스를 가리킴.

## 3. 생성자 함수와 일반 함수의 차이

- 생성자 함수는 반드시 new와 함께 호출해야 함.
- 그냥 호출하면 일반 함수처럼 동작하여 this가 전역 객체를 참조하게 됨 → undefined 반환.

```js
function Circle(radius) {
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

const c1 = new Circle(5); // 정상: Circle { radius: 5, getDiameter: f }
const c2 = Circle(10); // 일반 함수 호출 → 전역에 radius가 추가됨
```

## 4. 인스턴스 생성 과정 (new 실행 시 암묵적 처리)

### 1. 빈 객체 생성

자바스크립트 엔진이 내부적으로 빈 객체를 생성함.

### 2. this 바인딩

생성자 함수 내부에서 this는 자동으로 생성된 인스턴스를 가리킴.

### 3. 프로퍼티 및 메서드 초기화

생성자 함수 본문 코드가 실행되며, 전달된 인수를 바탕으로 this에 프로퍼티/메서드를 추가.

### 4. 인스턴스 반환

명시적으로 다른 객체를 return하지 않는 한, this가 암묵적으로 반환됨.

```js
function Circle(radius) {
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

// 암묵적 처리 예시
const c1 = new Circle(5);
// 1. 빈 객체 생성
// 2. this -> 빈 객체 바인딩
// 3. this.radius = 5; this.getDiameter = ...
// 4. 완성된 this 반환
```

## 5. return의 예외 케이스

- 생성자 함수 안에서 this가 아닌 다른 객체를 명시적으로 반환하면, 해당 객체가 반환됨.
- 그러나 원시값을 반환하면 무시되고, 암묵적으로 this가 반환됨.

```js
function Circle(radius) {
  this.radius = radius;
  return { custom: true }; // 명시적 객체 반환
}

const c = new Circle(10);
console.log(c); // { custom: true }
```

## 요약

- 객체 리터럴은 단순하지만 대량 생성에 비효율적.
- 생성자 함수는 여러 인스턴스를 효율적으로 생성할 수 있음.
- new 실행 시 JS 엔진이 자동으로 빈 객체 생성 → this 바인딩 → 초기화 → 반환 과정을 처리.
- return 문에서 객체를 반환하면 this 대신 그 객체가 반환됨.

# 함수는 역시 객체이다.

## 1. 함수는 객체다

- 함수도 객체이므로 프로퍼티와 메서드를 가질 수 있음.
- 단, 일반 객체와 달리 호출 가능(callable) 하다는 특징이 있음.
- 함수 객체는 내부적으로 `[[Call]]`, `[[Construct]]` 같은 내부 메서드를 가짐.
- `[[Call]]`: 일반 함수 호출 시 실행
- `[[Construct]]`: new 와 함께 호출될 때 실행

## 2. callable vs constructor vs non-constructor

- `callable`: 호출할 수 있는 객체 (모든 함수는 callable)
- `constructor`: new 와 함께 호출 가능 → 인스턴스 생성 가능
- `non-constructor`: new 와 함께 호출 불가 → new 사용 시 에러

### 구분 특징

`constructor` 함수 선언문, 함수 표현식, 클래스
`non-constructor` 화살표 함수, 메서드 축약 표현

```js
function Foo() {} // constructor
const bar = () => {}; // non-constructor
const obj = { x() {} }; // non-constructor
```

## 3. new 연산자

- 일반 함수와 생성자 함수는 형식상 차이 없음.
- new 와 함께 호출하면 [[Construct]] 실행 → 인스턴스 생성.
- new 없이 호출하면 [[Call]] 실행 → 일반 함수처럼 동작.
- 따라서 어떤 함수가 생성자 함수처럼 쓰일지는 new 사용 여부에 따라 결정됨.

```js
function Circle(radius) {
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

const c1 = new Circle(5); // 인스턴스 생성
console.log(c1.getDiameter()); // 10

const c2 = Circle(5); // 일반 호출
console.log(c2); // undefined
```

## 4. new.target

- new 와 함께 호출됐는지 확인할 수 있는 ES6 문법.
- 생성자 함수가 실수로 new 없이 호출되는 걸 방지할 수 있음.

```js
function Circle(radius) {
  if (!new.target) {
    return new Circle(radius); // new 없으면 강제로 new 붙여줌
  }
  this.radius = radius;
}

const c1 = Circle(5); // new 없어도 인스턴스 생성
const c2 = new Circle(10);
```

## 요약

1. 함수는 객체이며 [[Call]](일반 호출)과 [[Construct]](new 호출)을 가질 수 있음.
2. 모든 함수는 callable이지만, contructor는 여부에 따라, `constructor / non-constructor`로 나뉨.
3. function 선언/표현식은 `constructor`, 화살표 함수와 메서드 축약은 `non-constructor`.
4. `new.target` 으로 new 호출 여부 확인 가능 → 안전한 생성자 함수 구현 가능.
