# 자바스크립트와 객체지향 프로그래밍

- 자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 모두 지원하는 멀티 패러다임 언어.

- 클래스 기반 언어(C++, Java 등)와 달리 public, private, protected 같은 접근 제어자가 없어 오해를 받지만, 사실상 더 강력한 객체지향 프로그래밍 능력을 지니고 있음.

- ES6에서 class 문법이 도입되었지만, 사실상 프로토타입 기반 객체지향을 더 쉽게 사용할 수 있도록 제공한 문법적 설탕(syntactic sugar).

## 객체지향 프로그래밍(OOP)의 개념

- 프로그램을 명령어(절차) 중심으로 보는 전통적 명령형 프로그래밍과 달리, 여러 독립적 단위(객체)의 집합으로 프로그램을 표현.
- 객체지향 프로그래밍은 실세계의 사물이나 개념을 속성 **(attribute)** 과 메서드 **(method)** 를 가진 객체(object)로 추상화하여 코드로 옮김.

예시:

- 사람 → 이름, 주소, 성별, 나이 등의 속성(property).
- “이름이 아무개, 성별 여성, 나이 20세” 같은 속성 조합으로 특정 사람을 구별.
- 이렇게 필요한 속성만 간추려 표현하는 것을 **추상화(abstraction)** 라고 함.

## 자바스크립트 객체 표현

```js
const person = {
  name: "Lee",
  address: "Seoul",
};
console.log(person); // { name: "Lee", address: "Seoul" }
```

- person 객체는 이름과 주소 속성을 가진 객체로 다른 객체와 구별 가능.
- 속성을 통해 여러 값을 하나로 묶은 복합 자료구조를 만들 수 있음.

## 객체와 동작 결합

예: 원(circle) 객체

```js
const circle = {
  radius: 5,
  getDiameter() {
    return 2 * this.radius;
  },
  getPerimeter() {
    return 2 * Math.PI * this.radius;
  },
  getArea() {
    return Math.PI * this.radius ** 2;
  },
};
```

- radius는 원의 상태(state)를 나타내는 데이터.
- `getDiameter`, `getPerimeter`, `getArea`는 원의 상태 데이터를 사용해 계산하는 동작(behavior).
- 즉, 상태와 동작을 하나의 단위로 묶은 것이 객체지향 프로그래밍의 핵심.

## 객체 간의 관계와 재사용

- 객체는 고유 기능을 가진 독립적 단위이지만, 다른 객체와 상호작용(메시지 교환)을 통해 협력할 수 있음.
- 다른 객체의 데이터를 사용하거나, 동작을 상속받아 확장 가능.
- 이를 통해 재사용성과 유연성을 확보.

# 메서드 중복 문제와 프로토타입 상속

## 1. 메서드 중복 문제

- 생성자 함수(Circle) 안에서 메서드(getArea)를 정의하면,
  인스턴스가 생성될 때마다 동일한 메서드가 중복 생성된다.
- 예시:

```js
function Circle(radius) {
  this.radius = radius;
  this.getArea = function () {
    return Math.PI * this.radius ** 2;
  };
}

const c1 = new Circle(1);
const c2 = new Circle(2);

console.log(c1.getArea === c2.getArea); // false → 서로 다른 메모리에 생성됨
```

- 문제점:
- 같은 기능의 메서드가 인스턴스마다 새로 생성되어 메모리 낭비.
- 인스턴스가 많아질수록 퍼포먼스에 악영향.

## 2. 프로토타입을 통한 해결

- 자바스크립트는 프로토타입 기반 상속을 제공한다.
- 메서드를 프로토타입(Circle.prototype)에 정의하면,
  모든 인스턴스가 하나의 메서드를 공유할 수 있다.
- 예시:

```js
function Circle(radius) {
  this.radius = radius;
}

Circle.prototype.getArea = function () {
  return Math.PI * this.radius ** 2;
};

const c1 = new Circle(1);
const c2 = new Circle(2);

console.log(c1.getArea === c2.getArea); // true → 동일 메서드를 공유
```

- 작동 방식:
- `c1.getArea()` 호출 시,
  → c1 객체 안에서 `getArea` 탐색 → 없음
  → **proto** (프로토타입)에서 탐색 → `Circle.prototype.getArea` 실행.
- 따라서 인스턴스들은 개별적으로 메서드를 소유하지 않고, 프로토타입 메서드를 상속받아 사용.

## 3. 장점

- 메모리 절약: 메서드가 하나만 생성되어 모든 인스턴스가 공유.
- 성능 향상: 인스턴스가 많아져도 중복 생성이 없음.
- 코드 재사용: 공통 기능을 프로토타입에 정의하여 유지보수 용이.

즉, 생성자 함수 내부에서 메서드를 정의하면 중복 문제가 생기지만,
프로토타입을 활용하면 모든 인스턴스가 동일 메서드를 공유하여 효율적이다.
